<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>verifiable_credentials.issue API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>verifiable_credentials.issue</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># COMPONENTS ============================
import copy
import uuid
from typing import List, Generator, Dict, Tuple

from pyld import jsonld

from verifiable_credentials.components import Issuer, Assertion, Recipient, AnchorHandler, Blockcert, Batch
from verifiable_credentials.helpers import NOW
from .helpers import MerkleTree


class BlockcertsBatch(Batch):
    &#34;&#34;&#34;Representation of a Blockcerts batch.

    When issuing Blockcerts, using batches is the most cost-effective way of doing so since a single transaction is
    needed for potentially many certificates. Instead of anchoring a hash of each certificate in the blockchain, a
    Merkle Tree is created for the batch and its root is the one being anchored. Then the different certificates are
    updated with the Merkle Proof, which basically describes which hashes were needed (along with the hash of the
    current certificate) to finally create the Merkle Root.

    In order to issue a Blockcerts Batch you need to create the following things:
        - An Issuer
        - An Assertion
        - As many Recipients as you need
        - An Anchor Handler

    Once these are created all you need to do to issue a Blockcerts Batch is:

    &gt;&gt;&gt; from verifiable_credentials import issue
    &gt;&gt;&gt; batch = issue.BlockcertsBatch(
    ...     issuer=issuer,
    ...      assertion=assertion,
    ...      recipients=recipients,
    ...      anchor_handler=eth_anchor_handler,
    ... )
    &gt;&gt;&gt; tx_id, final_certs = batch.run()

    This would yield you:
        - A transaction id in `tx_id`, that tells you which transaction in the given blockchain contains the merkle root
        - A list of `final_certs` which are all the final Blockcerts you just issued.

    Note: if you&#39;re using this outside of a web service and wish to write the final Blockcerts as individual JSON files
    you could do something like:
    &gt;&gt;&gt; import json
    &gt;&gt;&gt; for id, cert in final_certs.items():
    ...     with open(f&#34;{id}.json&#34;, &#39;w&#39;) as this_cert_file:
    ...         this_cert_file.write(json.dumps(cert.to_dict()))

    :param issuer: Issuer object, contains info about who issues the Blockcert
    :param assertion: Assertion object, contains info about what is being claimed by the Issuer about the Recipient
    :param recipient: list of Recipient objects, they contain info about the entities receiving this Blockcert
    :param anchor_handler: AnchorHandler object, handles anchoring to a blockchain and updating the unsigned certs with
    transaction id and merkle proof.
    &#34;&#34;&#34;

    def __init__(self, issuer: Issuer, assertion: Assertion, recipients: List[Recipient],
                 anchor_handler: AnchorHandler):

        self.issuer = issuer
        self.assertion = assertion
        self.recipients = recipients
        self.anchor_handler = anchor_handler

        self.issued_on = NOW
        self._create_unsigned_certs()

        self.cert_generator = self._get_cert_generator()

        self.merkle_tree_generator = None
        self.merkle_root = None
        self.anchor_tx_id = None
        self.final_certs = None

    def _create_unsigned_certs(self):
        &#34;&#34;&#34;Compile the different inputs into an unsigned Blockcert.&#34;&#34;&#34;
        self.unsigned_certs = {}
        for recipient in self.recipients:
            this_id = str(uuid.uuid4())
            self.unsigned_certs[this_id] = Blockcert(
                id=this_id,
                issuer=self.issuer,
                assertion=self.assertion,
                recipient=recipient,
            )

    def _get_cert_generator(self) -&gt; Generator:
        &#34;&#34;&#34;Return a generator of jsonld-normalized unsigned certs.&#34;&#34;&#34;
        for uid, cert in self.unsigned_certs.items():
            normalized = jsonld.normalize(cert.to_dict(), {&#39;algorithm&#39;: &#39;URDNA2015&#39;, &#39;format&#39;: &#39;application/n-quads&#39;})
            yield normalized.encode(&#39;utf-8&#39;)

    def _add_proof_to_certs(self) -&gt; Dict:
        &#34;&#34;&#34;Add merkle proof to each of the certificates.&#34;&#34;&#34;
        proof_generator = self.merkle_tree_generator.get_proof_generator(
            self.anchor_tx_id,
            self.anchor_handler.signature_field,
            self.anchor_handler.chain_name
        )
        signed_certs = copy.deepcopy(self.unsigned_certs)
        for _, cert in signed_certs.items():
            proof = next(proof_generator)
            cert.proof = proof
        return signed_certs

    def run(self) -&gt; Tuple[str, Dict]:
        # Input validation is made by each component&#39;s init method, so it will fail before getting here.
        # 1- Create merkle tree
        self.merkle_tree_generator = MerkleTree()
        self.merkle_tree_generator.populate(self.cert_generator)
        self.merkle_root = self.merkle_tree_generator.get_root()

        self.anchor_tx_id = self.anchor_handler.anchor(
            self.merkle_tree_generator.get_root(binary=True)
        )
        self.final_certs = self._add_proof_to_certs()
        return self.anchor_tx_id, self.final_certs</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="verifiable_credentials.issue.BlockcertsBatch"><code class="flex name class">
<span>class <span class="ident">BlockcertsBatch</span></span>
<span>(</span><span>issuer, assertion, recipients, anchor_handler)</span>
</code></dt>
<dd>
<section class="desc"><p>Representation of a Blockcerts batch.</p>
<p>When issuing Blockcerts, using batches is the most cost-effective way of doing so since a single transaction is
needed for potentially many certificates. Instead of anchoring a hash of each certificate in the blockchain, a
Merkle Tree is created for the batch and its root is the one being anchored. Then the different certificates are
updated with the Merkle Proof, which basically describes which hashes were needed (along with the hash of the
current certificate) to finally create the Merkle Root.</p>
<p>In order to issue a Blockcerts Batch you need to create the following things:
- An Issuer
- An Assertion
- As many Recipients as you need
- An Anchor Handler</p>
<p>Once these are created all you need to do to issue a Blockcerts Batch is:</p>
<pre><code>&gt;&gt;&gt; from verifiable_credentials import issue
&gt;&gt;&gt; batch = issue.BlockcertsBatch(
...     issuer=issuer,
...      assertion=assertion,
...      recipients=recipients,
...      anchor_handler=eth_anchor_handler,
... )
&gt;&gt;&gt; tx_id, final_certs = batch.run()
</code></pre>
<p>This would yield you:
- A transaction id in <code>tx_id</code>, that tells you which transaction in the given blockchain contains the merkle root
- A list of <code>final_certs</code> which are all the final Blockcerts you just issued.</p>
<p>Note: if you're using this outside of a web service and wish to write the final Blockcerts as individual JSON files
you could do something like:</p>
<pre><code>&gt;&gt;&gt; import json
&gt;&gt;&gt; for id, cert in final_certs.items():
...     with open(f"{id}.json", 'w') as this_cert_file:
...         this_cert_file.write(json.dumps(cert.to_dict()))
</code></pre>
<p>:param issuer: Issuer object, contains info about who issues the Blockcert
:param assertion: Assertion object, contains info about what is being claimed by the Issuer about the Recipient
:param recipient: list of Recipient objects, they contain info about the entities receiving this Blockcert
:param anchor_handler: AnchorHandler object, handles anchoring to a blockchain and updating the unsigned certs with
transaction id and merkle proof.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BlockcertsBatch(Batch):
    &#34;&#34;&#34;Representation of a Blockcerts batch.

    When issuing Blockcerts, using batches is the most cost-effective way of doing so since a single transaction is
    needed for potentially many certificates. Instead of anchoring a hash of each certificate in the blockchain, a
    Merkle Tree is created for the batch and its root is the one being anchored. Then the different certificates are
    updated with the Merkle Proof, which basically describes which hashes were needed (along with the hash of the
    current certificate) to finally create the Merkle Root.

    In order to issue a Blockcerts Batch you need to create the following things:
        - An Issuer
        - An Assertion
        - As many Recipients as you need
        - An Anchor Handler

    Once these are created all you need to do to issue a Blockcerts Batch is:

    &gt;&gt;&gt; from verifiable_credentials import issue
    &gt;&gt;&gt; batch = issue.BlockcertsBatch(
    ...     issuer=issuer,
    ...      assertion=assertion,
    ...      recipients=recipients,
    ...      anchor_handler=eth_anchor_handler,
    ... )
    &gt;&gt;&gt; tx_id, final_certs = batch.run()

    This would yield you:
        - A transaction id in `tx_id`, that tells you which transaction in the given blockchain contains the merkle root
        - A list of `final_certs` which are all the final Blockcerts you just issued.

    Note: if you&#39;re using this outside of a web service and wish to write the final Blockcerts as individual JSON files
    you could do something like:
    &gt;&gt;&gt; import json
    &gt;&gt;&gt; for id, cert in final_certs.items():
    ...     with open(f&#34;{id}.json&#34;, &#39;w&#39;) as this_cert_file:
    ...         this_cert_file.write(json.dumps(cert.to_dict()))

    :param issuer: Issuer object, contains info about who issues the Blockcert
    :param assertion: Assertion object, contains info about what is being claimed by the Issuer about the Recipient
    :param recipient: list of Recipient objects, they contain info about the entities receiving this Blockcert
    :param anchor_handler: AnchorHandler object, handles anchoring to a blockchain and updating the unsigned certs with
    transaction id and merkle proof.
    &#34;&#34;&#34;

    def __init__(self, issuer: Issuer, assertion: Assertion, recipients: List[Recipient],
                 anchor_handler: AnchorHandler):

        self.issuer = issuer
        self.assertion = assertion
        self.recipients = recipients
        self.anchor_handler = anchor_handler

        self.issued_on = NOW
        self._create_unsigned_certs()

        self.cert_generator = self._get_cert_generator()

        self.merkle_tree_generator = None
        self.merkle_root = None
        self.anchor_tx_id = None
        self.final_certs = None

    def _create_unsigned_certs(self):
        &#34;&#34;&#34;Compile the different inputs into an unsigned Blockcert.&#34;&#34;&#34;
        self.unsigned_certs = {}
        for recipient in self.recipients:
            this_id = str(uuid.uuid4())
            self.unsigned_certs[this_id] = Blockcert(
                id=this_id,
                issuer=self.issuer,
                assertion=self.assertion,
                recipient=recipient,
            )

    def _get_cert_generator(self) -&gt; Generator:
        &#34;&#34;&#34;Return a generator of jsonld-normalized unsigned certs.&#34;&#34;&#34;
        for uid, cert in self.unsigned_certs.items():
            normalized = jsonld.normalize(cert.to_dict(), {&#39;algorithm&#39;: &#39;URDNA2015&#39;, &#39;format&#39;: &#39;application/n-quads&#39;})
            yield normalized.encode(&#39;utf-8&#39;)

    def _add_proof_to_certs(self) -&gt; Dict:
        &#34;&#34;&#34;Add merkle proof to each of the certificates.&#34;&#34;&#34;
        proof_generator = self.merkle_tree_generator.get_proof_generator(
            self.anchor_tx_id,
            self.anchor_handler.signature_field,
            self.anchor_handler.chain_name
        )
        signed_certs = copy.deepcopy(self.unsigned_certs)
        for _, cert in signed_certs.items():
            proof = next(proof_generator)
            cert.proof = proof
        return signed_certs

    def run(self) -&gt; Tuple[str, Dict]:
        # Input validation is made by each component&#39;s init method, so it will fail before getting here.
        # 1- Create merkle tree
        self.merkle_tree_generator = MerkleTree()
        self.merkle_tree_generator.populate(self.cert_generator)
        self.merkle_root = self.merkle_tree_generator.get_root()

        self.anchor_tx_id = self.anchor_handler.anchor(
            self.merkle_tree_generator.get_root(binary=True)
        )
        self.final_certs = self._add_proof_to_certs()
        return self.anchor_tx_id, self.final_certs</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="verifiable_credentials.components.Batch" href="components.html#verifiable_credentials.components.Batch">Batch</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="verifiable_credentials.components.Batch" href="components.html#verifiable_credentials.components.Batch">Batch</a></b></code>:
<ul class="hlist">
<li><code><a title="verifiable_credentials.components.Batch.run" href="components.html#verifiable_credentials.components.Batch.run">run</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="verifiable_credentials" href="../index.html">verifiable_credentials</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="verifiable_credentials.issue.BlockcertsBatch" href="#verifiable_credentials.issue.BlockcertsBatch">BlockcertsBatch</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>